{"ast":null,"code":"import { isDesktopChrome } from '@terra-dev/browser-check';\nimport { AccAddress, Extension } from '@terra-money/terra.js';\nimport { BehaviorSubject } from 'rxjs';\nimport { extensionFixer } from './extensionFixer';\nimport { clearStore, getStoredAddress, storeAddress } from './storage';\nimport { ChromeExtensionStatus } from './types';\nexport class ChromeExtensionController {\n  constructor(options) {\n    this.options = options;\n    this.doneFirstCheck = false;\n\n    this.status = () => {\n      return this._status.asObservable();\n    };\n\n    this.networkInfo = () => {\n      return this._networkInfo.asObservable();\n    };\n\n    this.terraAddress = () => {\n      return this._terraAddress.asObservable();\n    };\n\n    this.checkStatus = async (waitingExtensionScriptInjection = false) => {\n      // do not check if browser isn't a chrome\n      if (!this.isDesktopChrome) {\n        return;\n      } // ignore the checks before first check done\n      // first check -------------------------------→ done\n      // --------------- second check (ignore)\n\n\n      if (!waitingExtensionScriptInjection && !this.doneFirstCheck) {\n        return;\n      } // check the extension installed\n\n\n      const isExtensionInstalled = waitingExtensionScriptInjection ? await intervalCheck(20, () => this._extension.isAvailable()) : this._extension.isAvailable();\n      this.doneFirstCheck = true;\n\n      if (!isExtensionInstalled) {\n        this._status.next(ChromeExtensionStatus.UNAVAILABLE);\n\n        return;\n      } // get networkInfo from extension\n\n\n      const infoPayload = await this._extension.info();\n\n      if (infoPayload && this._networkInfo.getValue().chainID !== infoPayload.chainID) {\n        this._networkInfo.next(infoPayload);\n      }\n\n      if (this.options.enableWalletConnection) {\n        const storageStoredWalletAddress = getStoredAddress(); // if the storage has wallet address\n\n        if (storageStoredWalletAddress && AccAddress.validate(storageStoredWalletAddress)) {\n          this._status.next(ChromeExtensionStatus.WALLET_CONNECTED); // TODO timer check?\n\n\n          const connectResult = await this._extension.connect(); // if address of extension is not same with the address of localStorage\n\n          if (connectResult.address && AccAddress.validate(connectResult.address)) {\n            storeAddress(connectResult.address);\n          }\n\n          if (!!connectResult.address) {\n            if (this._terraAddress.getValue() !== connectResult.address) {\n              this._terraAddress.next(connectResult.address);\n            }\n          } else {\n            clearStore();\n\n            this._status.next(ChromeExtensionStatus.WALLET_NOT_CONNECTED);\n          }\n        } else {\n          if (storageStoredWalletAddress) {\n            clearStore();\n          }\n\n          this._status.next(ChromeExtensionStatus.WALLET_NOT_CONNECTED);\n\n          this._terraAddress.next(null);\n        }\n      } else {\n        this._status.next(ChromeExtensionStatus.WALLET_NOT_CONNECTED);\n\n        this._terraAddress.next(null);\n      }\n    };\n\n    this.connect = async () => {\n      var _a;\n\n      const result = await this._extension.connect();\n\n      if (result === null || result === void 0 ? void 0 : result.address) {\n        const walletAddress = result.address;\n        storeAddress(walletAddress);\n        await this.checkStatus();\n      }\n\n      return (_a = result === null || result === void 0 ? void 0 : result.address) !== null && _a !== void 0 ? _a : false;\n    };\n\n    this.disconnect = () => {\n      clearStore();\n      this.checkStatus();\n    };\n\n    this.recheckStatus = () => {\n      if (!this._extension.inTransactionProgress()) {\n        this.checkStatus(false);\n      }\n    };\n\n    this.post = data => {\n      return this._extension.post(data);\n    };\n\n    this.sign = data => {\n      return this._extension.sign(data);\n    };\n\n    this.isDesktopChrome = typeof window !== 'undefined' && isDesktopChrome(options.dangerously__chromeExtensionCompatibleBrowserCheck(navigator.userAgent));\n    this._status = new BehaviorSubject(this.isDesktopChrome ? ChromeExtensionStatus.INITIALIZING : ChromeExtensionStatus.UNAVAILABLE);\n    this._networkInfo = new BehaviorSubject(options.defaultNetwork);\n    this._terraAddress = new BehaviorSubject(getStoredAddress());\n    this._extension = extensionFixer(new Extension());\n\n    if (this.isDesktopChrome) {\n      this.checkStatus(true);\n    }\n  }\n\n}\n\nasync function intervalCheck(count, fn, intervalMs = 500) {\n  let i = -1;\n\n  while (++i < count) {\n    if (fn()) {\n      return true;\n    }\n\n    await new Promise(resolve => setTimeout(resolve, intervalMs));\n  }\n\n  return false;\n}","map":{"version":3,"sources":["../../../src/@terra-dev/chrome-extension/ChromeExtensionController.ts"],"names":[],"mappings":"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","sourcesContent":["import { isDesktopChrome } from '@terra-dev/browser-check';\nimport { NetworkInfo } from '@terra-dev/wallet-types';\nimport { AccAddress, Extension } from '@terra-money/terra.js';\nimport { BehaviorSubject } from 'rxjs';\nimport { extensionFixer, FixedExtension } from './extensionFixer';\nimport { clearStore, getStoredAddress, storeAddress } from './storage';\nimport { ChromeExtensionStatus } from './types';\n\nexport interface ChromeExtensionControllerOptions {\n  defaultNetwork: NetworkInfo;\n  enableWalletConnection: boolean;\n  dangerously__chromeExtensionCompatibleBrowserCheck: (\n    userAgent: string,\n  ) => boolean;\n}\n\nexport class ChromeExtensionController {\n  readonly _status: BehaviorSubject<ChromeExtensionStatus>;\n  readonly _networkInfo: BehaviorSubject<NetworkInfo>;\n  readonly _terraAddress: BehaviorSubject<string | null>;\n  readonly _extension: FixedExtension;\n\n  private doneFirstCheck = false;\n  private readonly isDesktopChrome: boolean;\n\n  constructor(readonly options: ChromeExtensionControllerOptions) {\n    this.isDesktopChrome =\n      typeof window !== 'undefined' &&\n      isDesktopChrome(\n        options.dangerously__chromeExtensionCompatibleBrowserCheck(\n          navigator.userAgent,\n        ),\n      );\n\n    this._status = new BehaviorSubject<ChromeExtensionStatus>(\n      this.isDesktopChrome\n        ? ChromeExtensionStatus.INITIALIZING\n        : ChromeExtensionStatus.UNAVAILABLE,\n    );\n\n    this._networkInfo = new BehaviorSubject<NetworkInfo>(\n      options.defaultNetwork,\n    );\n\n    this._terraAddress = new BehaviorSubject<string | null>(getStoredAddress());\n\n    this._extension = extensionFixer(new Extension());\n\n    if (this.isDesktopChrome) {\n      this.checkStatus(true);\n    }\n  }\n\n  status = () => {\n    return this._status.asObservable();\n  };\n\n  networkInfo = () => {\n    return this._networkInfo.asObservable();\n  };\n\n  terraAddress = () => {\n    return this._terraAddress.asObservable();\n  };\n\n  checkStatus = async (waitingExtensionScriptInjection: boolean = false) => {\n    // do not check if browser isn't a chrome\n    if (!this.isDesktopChrome) {\n      return;\n    }\n\n    // ignore the checks before first check done\n    // first check -------------------------------→ done\n    // --------------- second check (ignore)\n    if (!waitingExtensionScriptInjection && !this.doneFirstCheck) {\n      return;\n    }\n\n    // check the extension installed\n    const isExtensionInstalled = waitingExtensionScriptInjection\n      ? await intervalCheck(20, () => this._extension.isAvailable())\n      : this._extension.isAvailable();\n\n    this.doneFirstCheck = true;\n\n    if (!isExtensionInstalled) {\n      this._status.next(ChromeExtensionStatus.UNAVAILABLE);\n      return;\n    }\n\n    // get networkInfo from extension\n    const infoPayload = await this._extension.info();\n\n    if (\n      infoPayload &&\n      this._networkInfo.getValue().chainID !== infoPayload.chainID\n    ) {\n      this._networkInfo.next(infoPayload);\n    }\n\n    if (this.options.enableWalletConnection) {\n      const storageStoredWalletAddress: string | null = getStoredAddress();\n\n      // if the storage has wallet address\n      if (\n        storageStoredWalletAddress &&\n        AccAddress.validate(storageStoredWalletAddress)\n      ) {\n        this._status.next(ChromeExtensionStatus.WALLET_CONNECTED);\n\n        // TODO timer check?\n        const connectResult = await this._extension.connect();\n\n        // if address of extension is not same with the address of localStorage\n        if (\n          connectResult.address &&\n          AccAddress.validate(connectResult.address)\n        ) {\n          storeAddress(connectResult.address);\n        }\n\n        if (!!connectResult.address) {\n          if (this._terraAddress.getValue() !== connectResult.address) {\n            this._terraAddress.next(connectResult.address);\n          }\n        } else {\n          clearStore();\n          this._status.next(ChromeExtensionStatus.WALLET_NOT_CONNECTED);\n        }\n      } else {\n        if (storageStoredWalletAddress) {\n          clearStore();\n        }\n\n        this._status.next(ChromeExtensionStatus.WALLET_NOT_CONNECTED);\n        this._terraAddress.next(null);\n      }\n    } else {\n      this._status.next(ChromeExtensionStatus.WALLET_NOT_CONNECTED);\n      this._terraAddress.next(null);\n    }\n  };\n\n  connect = async () => {\n    const result = await this._extension.connect();\n\n    if (result?.address) {\n      const walletAddress: string = result.address;\n      storeAddress(walletAddress);\n\n      await this.checkStatus();\n    }\n\n    return result?.address ?? false;\n  };\n\n  disconnect = () => {\n    clearStore();\n    this.checkStatus();\n  };\n\n  recheckStatus = () => {\n    if (!this._extension.inTransactionProgress()) {\n      this.checkStatus(false);\n    }\n  };\n\n  post = <SendData extends {}, Payload extends {}>(\n    data: SendData,\n  ): Promise<{ name: string; payload: Payload }> => {\n    return this._extension.post(data);\n  };\n\n  sign = <SendData extends {}, Payload extends {}>(\n    data: SendData,\n  ): Promise<{ name: string; payload: Payload }> => {\n    return this._extension.sign(data);\n  };\n}\n\nasync function intervalCheck(\n  count: number,\n  fn: () => boolean,\n  intervalMs: number = 500,\n): Promise<boolean> {\n  let i: number = -1;\n  while (++i < count) {\n    if (fn()) {\n      return true;\n    }\n    await new Promise((resolve) => setTimeout(resolve, intervalMs));\n  }\n  return false;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}